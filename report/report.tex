\title{Babble}
\author{Wander Nauta (s1380893) \and Derk Snijders (s0000000) }
\date{\today}

\documentclass[a4paper]{article}

\usepackage[sc]{mathpazo}
\usepackage{parskip}
\usepackage{microtype}
\usepackage[utf8]{inputenc}
\usepackage{inconsolata}
\usepackage{appendix}
\usepackage{color}
\usepackage[usenames,svgnames]{xcolor}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{titlesec}
\usepackage{nag}
\usepackage[margin=1.3in]{geometry}

\newcommand{\sectionbreak}{\clearpage}
\input{pygments}

\lstset{
	basicstyle=\ttfamily,
	keepspaces=true,
	numbers=none,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=4
}

\begin{document}

\begin{titlepage}
\maketitle
\end{titlepage}

\tableofcontents

\section{Language summary}

Babble is a compiled, duck-typed, object-oriented programming language for the Java Virtual machine.
It has syntax and semantics inspired by the Smalltalk programming language, but the compile-once-run-anywhere development cycle from Java.
It has no primitives, no operators, no statements like \texttt{if} or \texttt{while}, and no type annotations.
Instead, most everything in Babble is done using message sends.

In Babble, as in Smalltalk, everything is an object, and objects can be interacted with by sending them messages.
If the receiving object understands the message, it acts upon it, sending messages to other objects if required, and finally sending a reply back to the source of the message.
(The process of sending messages would be described as `calling methods' in other languages, while sending a reply would be called `returning a value'.
We use the terms interchangeably.)

Babble is duck typed.
It is a (run-time) error if a receiving object does not understand a message.

Like Smalltalk, Babble has the concept of blocks: pieces of code that can be passed as values.
Blocks can take arguments, and will also do lambda closure.

\section{Problems and solutions.}
Summary of problems you encountered and how you solved them (max. two
pages).

\section{Detailed language description}
%A systematic description of the features of your language, for each
%feature specifying
%– Syntax, including one or more examples;
%– Usage: how should the feature be used? Are there any typing or other restrictions?
%– Semantics: what does the feature do? How will it be executed?
%– Code generation: what kind of target code is generated for the feature?
%You may make use of your ANTLR grammar ar as a basis for this description, but note that %not every
%rule necessarily corresponds to a language feature

\subsection{Defining classes}

A Babble program is a collection of Babble classes.

A class is defined by a name, an ID, a possible superclass and then opening brackets. Inside these brackets class fields can optionally be declared using a deceleration syntax. Following field declaration are the methods the class has that provide functionality.

Example:
\begin{quote}
\begin{lstlisting}
Duck extends:Animal [
	| age hungry|.
	
	birthday [].
	
	eat: food [].
	
	+: with [].
].
\end{lstlisting}
\end{quote}

Unlike in Java, multiple classes can be defined in a single file, and a single class can be defined in multiple files (see section \ref{merge}). A separate Java .class file is generated from each Babble class in the program (after merging), having declarations as fields and Babble methods as methods.

As in Java, these classes do nothing when their methods are not being called. A program can be started from every class that has a Babble method with the name 'main', from here on other classes can be constructed and used in the program.


\subsection{Defining methods}

Classes on themselves are quite empty, their functionality is defined inside methods defined in the class. The general syntax is a method name optionally followed by parameters and then a block containing a list of expressions to be executed in order.
There are three different kind of methods, each having slight variations on the general syntax.

Babble methods are translated into Java methods belonging to their corresponding class.


\subsubsection{Unary methods}

A unary method is a method without arguments, an example on how such a method would be defined can be given using the Duck example:

\begin{quote}
\begin{lstlisting}
birthday [
	age := age + 1.
].
\end{lstlisting}
\end{quote}
This method tells the Duck to increment it's age field by 1.

\subsubsection{Keyword methods}
A keyword method is a method with 1 or more arguments, an example on how such a method would be defined can be given using the Duck example:

\begin{quote}
\begin{lstlisting}
eat: food [
	food consume.
	hungry := false.
].
\end{lstlisting}
\end{quote}
This method would tell the food it is consumed and then set the Duck's hungry status to false.

The syntactical difference between unary and keyword methods is in the parameters that the method definition expects. After the name, parameters can be defined using a colon. The name given to the parameter can then be used inside the method body to refer to the value that would be passed as an argument. Following is an example of a multiple-parameter keyword method:

\begin{quote}
\begin{lstlisting}
eat: soup and: potatoes finishWith: dessert [].
\end{lstlisting}
\end{quote}

\subsubsection{Infix methods}

Infix methods probably have the syntax most deviating from the general syntax. Infix method are defined using an operator instead of a identifier as name and always have 1 parameter. An example using the Duck class would be the following:

\begin{quote}
\begin{lstlisting}
+: with [
	(with class name == "Duck") ifTrue: [ Duck new. ].
].
\end{lstlisting}
\end{quote}
This method would return a new Duck when the original Duck is with another Duck.

\subsection{Declaring variables}
Variables in Babble can be declared either as class fields or as local variables in a method. In any case, variables do not have a single type and this is thus not specified. An example would be as follows:
\begin{quote}
\begin{lstlisting}
| variable1 variable2 |.
\end{lstlisting}
\end{quote}

Both classes and methods can optionally declare variables (Although a variable has to be declared before it can be used!). For classes this has to be done before any method definition. In methods, variable declaration can be intertwined with expressions, as long as a variable is declared before usage. Multiple variable declarations of the same name are not allowed.

While the syntax in classes and methods is the same for declaring variables, there is a difference in compiling. Variables declared in classes are added as fields to the JVM class, variables declared in methods are added as local variables to the JVM method.

%TODO method arguments?
%TODO closure variables?


\subsection{Sending messages}

The only way to have a Babble program do anything useful is by sending messages to objects, these messages can be seen as calling a method. Sending a message always returns a value, this is the value of the last expression that was executed in that method. Empty methods return a Nil object.

Since Babble is duck typed, there is no compile-time checking whether or not a message send to an object is appropriate. At runtime the message is send to an object. If the object has a method to handle the message everything goes well, in the other case an error occurs if the object does not have a method defined to handle the message sent.

There are again three different kind of messages, each with their own syntax.

%TODO main method -> How does our program start? This is currently touched upon in the class definition section.

\subsubsection{Unary messages}

Unary messages are similar to unary operators from other languages, or zero-argument methods in Java.
The following is an example on how to send a unary message:

\begin{quote}
\begin{lstlisting}
true not.
\end{lstlisting}
\end{quote}

The syntax is straightforward, a 'not' message is to the receiver, a True object.
The receiver will reply with a False object. In other words, this is a unary negation.

\subsubsection{Keyword messages}

Keyword messages are relatively uncommon: they mostly appear in Smalltalk-inspired languages, like Objective-C.
Keyword messages have one or more keywords, one per argument.
These keywords are used to determine which method to call.
For example, the following is a single keyword message:

\begin{quote}
\begin{lstlisting}
array at: 2 put: 10.
\end{lstlisting}
\end{quote}

This sends the message \texttt{at:put:} to the variable \texttt{array}, passing the 2 and 10 as arguments. This would place the number 10 at the third position inside the array.



\subsubsection{Infix messages}

Infix messages have selectors that consist entirely of symbols (like `+', `=', or `!'). For example:

\begin{quote}
\begin{lstlisting}
10 > 20.
\end{lstlisting}
\end{quote}

Like other messages, infix messages have exactly one receiver, in this case the integer 10.
Infix messages also have exactly one argument, the integer 20 here.
Because 10 is not larger than 20, the result will be false.


\subsubsection{Precedence}

Unary messages have the highest precedence, followed by infix messages, followed by keyword messages. Expressions are evaluated `from left to right'. Precedence can be forced using parenthesis, this can be necessary when having to send a message before applying the result:
\begin{quote}
\begin{lstlisting}
this class name == (that class name)
\end{lstlisting}
\end{quote}
If you leave out the parenthesis, the first class name would be compared to 'that' and the class name of the result of that expression (true or false) would be the value of the entire expression.

There are no special exceptions for `arithmetic' operators: all infix messages share the same precedence.
For example, \texttt{5 + 10 * 2} evaluates to 30, not 25.
To calculate $5 + 10 \times 2$ one would write \texttt{5 + (10 * 2)}.

The precedence rules from arithmetic make sense when doing arithmetic, but since Babble allows classes to provide their own infix methods, the symbols from arithmetic can be used in any context.
For example, `+' is used for string concatenation but also for Duck mating in the Duck example.
The asterisk could  be used as a string repeat method.
In that context, Babble will evaluate an expression like \texttt{"Hello" + "World" * 2} as "HelloWorldHelloWorld": in other words, left to right.

\subsection{Standard classes}

Babble comes with a few built-in classes. Most of these are based on their counterparts in Java.

\subsubsection{Integers}

Integer values in Babble can be arbitrarily large.

\subsubsection{Strings}

Babble has string literals. String literals are enclosed in double quotes, i.e. \verb|"Hello, world!"|.

\subsubsection{Symbols}

Symbols are written as \verb|#foo|.

\subsubsection{Arrays}

The syntax for array literals is \verb|{1, 2, 3}|.

\subsubsection{Blocks}

\subsection{Tips and tricks}

\subsubsection{Using symbols as enumerations}



\subsubsection{Using blocks as values}

\subsubsection{Using values as blocks}

\subsubsection{Introspection and metaclasses}

Babble offers some amount of introspection into objects: objects can be queried for their class by sending them the \texttt{class} message.
The resulting metaclass instance can then be asked for information about the original class using the \texttt{name} and \texttt{methods} messages.
It can also tell you whether or not the original object will \texttt{respondTo} a certain message.

\label{merge}
\subsubsection{Adding methods to existing classes}

The Babble compiler will merge class definitions with the same name together.
This means that you can extend a class from multiple places in your program.

\subsubsection{Adding methods to metaclasses}

\section{Description of the software}
Summary of the JAVA classes you implemented; for instance, for symbol
table management, type checking, code generation, error handling, etc. In your description, rely
on the concepts and terminology you learned during the course, such as synthesised and inherited
attributes, tree listeners and visitors

The program itself is a compiler that translates Babble source code into JVM bytecode.
While the compiler does check whether variable names are defined, it can't (and won't try to) do any compile-time type checking.

\subsection{Compiler}

The Babble compiler is split into a front end, a few (relatively small) intermediate passes, and a (relatively large) bytecode generation back end.

\subsubsection{Front end: parser}

Babble's parser is based on ANTLR.
The ANTLR grammar has been included on page \pageref{grammar}.
The resulting parse tree is converted into a tree-based intermediate representation using the visitor on page \pageref{visitor}.

\subsubsection{Intermediate passes}

When the program is parsed, it goes through a few intermediate passes, most of which either annotate the tree representation of the program in some way, or check its semantics.

\subsubsection{Back end: bytecode generator}

The Babble compiler generates Java Virtual Machine bytecode using the ASM bytecode manipulation library from Objectweb.
% ...

\subsection{Runtime environment}

\subsubsection{invokeDynamic}

\section{Test plan and results}
Discussion of the correctness test, using the criteria described in §B.5. You
should provide a set of test programs demonstrating the correct functioning of your compiler. The test
set should contain, next to programs testing the various language featurs, also programs containing
syntactic, semantic or run-time errors.
All tests should be provided as part of the zip-file. One test program should be included as an appendix
in the report (see below).


The Babble compiler itself is tested using unit tests, written in Java, while the runtime system is tested using integration tests, written in Babble.
Both can be executed using Maven by running \texttt{mvn verify}.
Maven can also generate a graphical (HTML) report of the test results using \texttt{mvn site}.
% ...

\section{Conclusions}

\clearpage

\begin{appendices}

\label{grammar}
\section{ANTLR grammar}

\input{grammar}
%TODO UPDATE GRAMMAR!!?!?!?

\label{visitor}
\section{ANTLR tree visitor}
The complete listing of each implementation of a
tree listener or tree visitor for your grammar.

This tree visitor converts an ANTLR parse tree into our intermediate representation, the IR tree.

\input{visitor}
%TODO MORE VISITORS!!!!

\section{Extended test program}
The listing of one (correct) extended test program, as well as the generated
target code for that program and one or more example executions showing the correct functioning of
the generated code.

\end{appendices}

\end{document}
